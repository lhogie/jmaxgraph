\documentclass[11pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\title{JMaxGraph\\ on analysing with huge graphs}
\author{Luc Hogie, Frédéric Giroire, Stéphane Perennes, Thibaud Trolliet}
\begin{document}
\maketitle

JMaxGraph is a Java middleware for the analysis of large graphs. It was born out of the inability of common graph libraries
to deal with large datasets. These limitations are the drawback of using object-oriented models which  have huge memory
overheads and inefficient:
\begin{itemize}
\item  memory models: they usually rely on  --- whose the main drawback is to
\item memory access strategies: most libraries rely on 
\end{itemize}

\section{Measure performance}
On the NEF Inria cluster.
\begin{itemize}
\item loading up to 2GB/s, loading the entire Twitter text ADJ file (215GB) took 7min.
\item iterating on 500M vertices takes 1s.
\end{itemize}
Loading
\section{The text ADJ file format}
First line is the number of vertices. Each following line then consists of:
\begin{enumerate}
\item the ID of the vertex;
\item the number of neighbors;
\item the ID for each neighbor.
\end{enumerate}
It takes lots of disk space: slow to read, to parse and to manipulate.
Twitter graph takes 215GB. 
On NEF, using 8 threads, reading it takes 7min.

\section{The binary ADJ file format}
The same of text ADJ, but each number/vertex is represented by a sequence of 4 bytes.
The size can be reduced up to 3.

\section{The JMG file format}
In the JMG format, the graph is described by several files in a directory.

The JMG file format ensures that, after loading:
\begin{enumerate}
\item adjacency lists are sorted
\item there is no vertex in adjancency lists that is not in the vertex set.
\end{enumerate}


\subsection{\texttt{properties.txt}}
The \texttt{properties.txt} is an ASCII text file. It consists of a sequence of lines with all the same following synax:
$$
key=value
$$
The \# character indicates that a comment is starting, discarding the rest of the line.
The \texttt{properties.txt}  is useful to describe properties for the graph.

When creating a graph for a JMG dataset, JMaxGraph scans the \texttt{properties.txt} file for the \textit{nbVertices} properties, which defines the vertex set as all consecutive vertices in $[0\  nbVertices]$.

\subsection{Adjacency files}
A JMG dataset is very likely to come with a description for the adjacencies of either IN or OUT directions. If if does not, you will only be able to work on the vertex set.
The IN (resp. OUT) adjacency is expected to be found in a file \texttt{in.edg} (resp. \texttt{out.edg}). Such adjacency file comes with its index file, called \texttt{-index.nbs} (see  (see \ref{nbsfile}).
For each vertex $u$, the index file has an entry which gives the position in the adjacency file at which the set of neighbors of $u$ are stored.

This set of neighbors is encoded at a byte sequence of length:
$$l = index(u+1) - index(u)$$
 Note that if $u$ is the vertex with the highest ID,  they does not exist such thing as $index(u+1))$. The length of the byte sequence describing its neighborhoods is then defined by:
 $$l = size(indexFile) - index(u)$$
Note also that the number neighbors cannot be computed out of this $l$, as every vertex may use words of different length to store their neighborhood.

Then, starting at position $index(u)$, the byte sequence encoding the set of neighbors for vertex $u$ is organized like this:
\begin{enumerate}
\item 8 bytes encode the neighbor with lowest ID
\item 1 byte encodes the number of bytes used to store each other neighbor, let us refer to it as $e$. The number of neighbors is then defined by $1 + \frac{l - 9}{e}$.
\item each following neighbor $v_i$ of $u$ is encoded as the delta $d$ of its ID and the ID of the previous neighbor.
The ID of the $i^{th} (with\ i > 0)$ neighbor is obtained by:
$$v_i = v_{i-1} + d$$.
\end{enumerate}

\section{Encountered issues}
\subsection{The loading is too long}





\end{document}